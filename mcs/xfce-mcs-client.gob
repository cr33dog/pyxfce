%{
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <gdk/gdkx.h>

static void
weak_notify_cb(gpointer data, GObject *where_the_object_was)
{
	xfce_mcs_client_vanish_object (XFCE_MCS_CLIENT (data), where_the_object_was);
}

static void
notify_cb(const gchar *name, const gchar *channel_name,
  McsAction action, McsSetting * setting, void *cb_data)
{
	g_warning ("NOTIFY");
	xfce_mcs_client_setting_changed (XFCE_MCS_CLIENT (cb_data), name, channel_name, action, setting);
}

static GdkFilterReturn
client_event_filter (GdkXEvent * xevent, GdkEvent * event, gpointer data)
{
	XfceMcsClient	*c;
	McsClient	*m;
	
	c = (XfceMcsClient *)data;
	m = c->low;
	if (!m)
		return GDK_FILTER_REMOVE;
	
	if (mcs_client_process_event ((McsClient*) m, (XEvent *) xevent))
		return GDK_FILTER_REMOVE;
	else
		return GDK_FILTER_CONTINUE;
}

static void
watch_cb(Window window, gboolean is_start, long mask, void *data)
{
	GdkWindow *gdkwin;

	gdkwin = gdk_window_lookup (window);
        
	if (is_start)
		gdk_window_add_filter (gdkwin, client_event_filter, data);
	else
		gdk_window_remove_filter (gdkwin, client_event_filter, data);
}

static gboolean
my_ascii_strcasecmp(gconstpointer a, gconstpointer b)
{
	return g_ascii_strcasecmp ((gchar const *)a, (gchar const *)b) == 0;
}

%}

%a{
#include <gtk/gtk.h>
#include <libxfce4mcs/mcs-client.h>
#include "xfce-mcs-channel.h"
%}

class Xfce:Mcs:Client from G:Object {
	protected McsClient*	low = NULL
		destroy {
			mcs_client_destroy (VAR);
			VAR = NULL;
		};

	protected GHashTable	*channels /* name -> obj */
		destroy {
			g_hash_table_destroy (VAR);
		};

	protected GHashTable	*channels_r /* obj -> name */
		destroy {
			g_hash_table_destroy (VAR);
		};

	protected GdkScreen*	screen = NULL
		destroy {
			if (VAR)
				g_object_unref ((GdkScreen *)VAR);
			VAR = NULL;
		};

	property OBJECT screen
		(nick = "the screen to use",
		blurb = "The GdkScreen to use for the settings",
		object_type = Gdk:Screen,
		export)
		set {
			Display*	dpy;
			GdkScreen*	screen;
			screen = g_value_get_object (VAL);
			if (self->screen) {
				g_object_unref (G_OBJECT (self->screen));
				self->screen = NULL;
			}

			if (screen)
				self->screen = (GdkScreen *) g_object_ref (screen);
	
			if (self->low) {
				mcs_client_destroy (self->low);
				self->low = NULL;
			}
	
			dpy = GDK_DISPLAY_XDISPLAY (gdk_screen_get_display (screen));
			self->low = mcs_client_new (dpy, gdk_screen_get_number (screen), notify_cb, watch_cb, self);
	
			/* g_signal_emit_by_name (self, "manager-reconnect", NULL); */
			self_manager_reconnect (self); /* suffices */
		}
		get {
			g_value_set_object (VAL, self->screen);
		};

	signal first NONE (NONE)
	void manager_reconnect (self)
	{
		self_check_manager (self);
	}

	public Xfce:Mcs:Client *new(void)
	{
		XfceMcsClient *obj;
		obj = (XfceMcsClient *)GET_NEW;
		return obj;
	}

	protected void vanish_object(self, GObject *obj)
	{
		gchar*	channel_name;
		channel_name = g_hash_table_lookup (self->channels_r, obj);
		g_hash_table_remove (self->channels_r, obj);
		if (channel_name) {
			g_hash_table_remove (self->channels, channel_name);
			/* remove also frees channel_name */
		}
	}

	init(self)
	{
		self->channels = g_hash_table_new_full (g_str_hash, my_ascii_strcasecmp,
			g_free, NULL);

		self->channels_r = g_hash_table_new (g_direct_hash, g_direct_equal);
		
		g_object_set ((GObject *)self, "screen", gdk_screen_get_default (), NULL);
	}


	public void delete_channel(self, gchar const *name)
	{
		if (!self->low) {
			g_warning ("XfceMcsClient: delete_channel: property screen not set.");
			return;
		}
		mcs_client_delete_channel (self->low, name);
	}
	
	/* will _weakref, not _ref */
	public void add_channel(self, XfceMcsChannel *channel)
	{
		gpointer	obj;
		gchar*		xname;
		gchar const*	name;
		
		name = xfce_mcs_channel_get_channel_name (channel);
		
		obj = g_hash_table_lookup (self->channels, name);

		g_return_if_fail (obj == NULL);
			
		obj = channel;
		g_object_weak_ref ((GObject *)obj, weak_notify_cb, self);
		xname = g_strdup (name);
		g_hash_table_insert (self->channels, xname, obj);
		g_hash_table_insert (self->channels_r, obj, xname);

		xfce_mcs_channel_add_to_driver (channel, XFCE_MCS_CHANNEL_SIDE_CLIENT, name);

		return obj;
	}


	protected void setting_changed (self, gchar const *name, gchar const *channel_name, McsAction action, McsSetting *setting)
	{
		gpointer	obj;
		obj = g_hash_table_lookup (self->channels, channel_name);
		if (obj) {
			switch (action) {
			case MCS_ACTION_NEW:
				xfce_mcs_channel_setting_added (XFCE_MCS_CHANNEL (obj), name);
				xfce_mcs_channel_setting_changed (XFCE_MCS_CHANNEL (obj), name); /* just in case the client monitors just one */
				break;
		
			case MCS_ACTION_CHANGED:
				xfce_mcs_channel_setting_changed (XFCE_MCS_CHANNEL (obj), name);
				break;
				
			case MCS_ACTION_DELETED:
				xfce_mcs_channel_setting_deleted (XFCE_MCS_CHANNEL (obj), name);
				break;
			}
		}
	}

	protected McsSetting* get_setting(self, gchar const *channel_name, gchar const *name)
	{
		McsSetting*	setting;
		setting = NULL;
		if (mcs_client_get_setting (self->low, name, channel_name, &setting) == MCS_SUCCESS) {
		} else
			setting = NULL;

		return setting;
	}
	
	public gboolean check_manager(self)
	{
		Display*	dpy;
		
		if (self->screen == NULL)
			return FALSE;
		
		dpy = GDK_DISPLAY_XDISPLAY (gdk_screen_get_display (self->screen));
		return mcs_client_check_manager (dpy, gdk_screen_get_number (self->screen), "xfce-mcs-manager");
	}
	
	public void show_dialog(self, gchar const *message)
	{
		Display*	dpy;
		if (!self->screen) {
			g_warning ("XfceMcsClient: show_dialog: screen property is NULL, not showing dialog.");
			return;
		}
			
		dpy = GDK_DISPLAY_XDISPLAY (gdk_screen_get_display (self->screen));
		mcs_client_show (dpy, gdk_screen_get_number (self->screen), message);
	}

}
